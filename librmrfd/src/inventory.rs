use std::sync::Arc;
use std::io;
use std::collections::{BTreeMap, HashMap, HashSet};
use std::thread;

use dirinventory::{openat, InventoryEntryMessage, ObjectPath};
use crossbeam_channel::{unbounded, Receiver, Sender};
use openat::{metadata_types, Metadata};
#[allow(unused_imports)]
use log::{debug, error, info, trace, warn};

use crate::objectlist::ObjectList;

/// Stores all paths generated by the inventory gather pass.  The Inventory stores paths in
/// sub maps per device id, each sorted by size and inode.
#[derive(Debug)]
pub struct Inventory {
    // output: Receiver<InventoryMessage>,
}

impl Inventory {
    /// Create a new Inventory.
    pub fn new(channels: Vec<Arc<Receiver<InventoryEntryMessage>>>) -> io::Result<Arc<Inventory>> {
        (0..channels.len()).try_for_each(|n| -> io::Result<()> {
            let receiver = channels[n].clone();
            let mut inventory_map = InventoryMap::new();

            let max_blkcnt: metadata_types::blkcnt_t = 0;

            thread::Builder::new()
                .name(format!("inventory/{}", n))
                .spawn(move || {
                    debug!("thread started: {}", thread::current().name().unwrap());
                    loop {
                        use crate::inventory::InventoryEntryMessage::*;
                        match receiver.recv().unwrap(/*TODO: thread exit */) {
                            Metadata { path, metadata, .. } => {
                                trace!("got metadata for: {:?}", path);
                                // PLANNED: early delete, if nlinks == 1 && blkcnt =>
                                // max_blkcnt_so_far/2
                                inventory_map.insert_with_metadata(path, &metadata);
                            }
                            EndOfDirectory { .. } | Entry { .. } => { /* ignored, unused */ }
                            Err { path, error } => { /*TODO: pass error up */ }
                            Done => {
                                inventory_map.fastrmrf_files();
                                // TODO: slowrmrf (while receiver.is_empty())
                                // TODO: signal done
                            }
                        }
                    }
                })
                .map(|_| Ok(()))?
        })?;

        Ok(Arc::new(Inventory {}))
    }
}

/// The per-thread storage maping files:size+inode:device
struct InventoryMap {
    map: HashMap<metadata_types::dev_t, BTreeMap<ObjectKey, ObjectList>>,
}

impl InventoryMap {
    fn new() -> InventoryMap {
        InventoryMap {
            map: HashMap::new(),
        }
    }

    fn fastrmrf_files(&mut self) {
        // PLANNED: one thread per device
        for device in self.devices() {
            debug!("start fastrmrf for dev {}", device);
            // delete all elements where all hardlinks are collected
            self.map
                .get_mut(&device)
                .unwrap()
                .iter_mut()
                .rev()
                .filter(|(_, object_list)| {
                    object_list
                        .first()
                        .and_then(|f| f.metadata().ok())
                        .and_then(|m| m.nlink())
                        == Some(object_list.len() as metadata_types::nlink_t)
                })
                .for_each(|(_, object_list)| {
                    object_list.ditch(|object| {
                        // TODO: REALLY DELETE
                        trace!("fast delete {:?}", object);
                        // PLANNED: accounting, sum up memory freed
                        true
                    });
                });

            // prune all unused objectmaps with empty objectlists
            self.map
                .get_mut(&device)
                .unwrap()
                .retain(|_, objectlist| !objectlist.is_empty());
        }
    }

    /// Returns a HashSet of all known device identifiers.
    pub fn devices(&self) -> HashSet<metadata_types::dev_t> {
        let mut devices = HashSet::new();

        for device in self.map.keys() {
            devices.insert(*device);
        }

        devices
    }

    // PLANNED: insert/remove/contains with shard parameter, then one thread per shard can
    //          fill the inventory

    // Insert the given path, using the supplied metadata to determine where the path will be stored.
    pub fn insert_with_metadata(
        &mut self,
        path: Arc<ObjectPath>,
        metadata: &Metadata,
    ) -> io::Result<()> {
        let key = ObjectKey::try_from(metadata)
            .ok_or_else(|| io::Error::from(io::ErrorKind::NotFound))?;

        let map = self
            .map
            .entry(
                metadata
                    .dev()
                    .ok_or_else(|| io::Error::from(io::ErrorKind::NotFound))?,
            )
            .or_insert(BTreeMap::new());

        // and get/create the objectlist, insert path
        map.entry(key).or_insert_with(ObjectList::new).insert(path);

        Ok(())
    }

    /// Remove the given path under the supplied metadata from the inventory.
    pub fn remove_with_metadata(
        &mut self,
        path: Arc<ObjectPath>,
        metadata: &Metadata,
    ) -> io::Result<()> {
        let key = ObjectKey::try_from(metadata)
            .ok_or_else(|| io::Error::from(io::ErrorKind::NotFound))?;

        self.map
            .get_mut(
                &metadata
                    .dev()
                    .ok_or_else(|| io::Error::from(io::ErrorKind::NotFound))?,
            )
            .ok_or_else(|| io::Error::from(io::ErrorKind::NotFound))?
            .get_mut(&key)
            .ok_or_else(|| io::Error::from(io::ErrorKind::NotFound))?
            .remove(path);

        Ok(())
    }

    /// Checks if the given path/metadata exists in the inventory.
    pub fn contains_with_metadata(&self, path: Arc<ObjectPath>, metadata: &Metadata) -> bool {
        ObjectKey::try_from(metadata)
            .and_then(|key| Some(self.map[&metadata.dev()?].get(&key)?.contains(path)))
            .unwrap_or(false)
    }

    /// Insert existing path (on filesystem) into the inventory. Retrives the metadata from the
    /// path.  Will result in an error when the metadata of the given path can't be retrieved.
    pub fn insert(&mut self, path: Arc<ObjectPath>) -> io::Result<()> {
        let metadata = path.metadata()?;
        self.insert_with_metadata(path, &metadata)
    }

    /// Remove existing path (on filesystem) from the inventory. Retrives the metadata from the
    /// path.  Will result in an error when the metadata of the given path can't be retrieved.
    pub fn remove(&mut self, path: Arc<ObjectPath>) -> io::Result<()> {
        let metadata = path.metadata()?;
        self.remove_with_metadata(path, &metadata)
    }

    /// Check if an existing path (on filesystem) exists in the inventory. Retrives the
    /// metadata from the path.  Will return false when the metadata of the given path can't be
    /// retrieved.
    pub fn contains(&self, path: Arc<ObjectPath>) -> bool {
        path.metadata()
            .map(|metadata| self.contains_with_metadata(path, &metadata))
            .unwrap_or(false)
    }
}

/// Objects are looked up by size and inode number combined here.
#[derive(Debug, Eq)]
pub struct ObjectKey {
    blocks: metadata_types::blkcnt_t,
    ino:    metadata_types::ino_t,
}

impl ObjectKey {
    /// Create a ObjectKey from the given metadata. May fail and return None when the metadata
    /// entries can't be acquired.
    pub fn try_from(metadata: &Metadata) -> Option<ObjectKey> {
        Some(ObjectKey {
            blocks: metadata.blocks()?,
            ino:    metadata.ino()?,
        })
    }

    /// Extremely simple hashing to determine the shard where the object is stored.
    pub fn bucket_hash(&self) -> usize {
        let mut h = self.blocks as usize ^ self.ino as usize;
        h = h ^ (h >> (usize::BITS / 2));
        h ^ (h >> (usize::BITS / 4))
    }
}

use std::cmp::Ordering;
impl Ord for ObjectKey {
    fn cmp(&self, other: &Self) -> Ordering {
        let r = self.blocks.cmp(&other.blocks);
        if r == Ordering::Equal {
            self.ino.cmp(&other.ino)
        } else {
            r
        }
    }
}

impl PartialOrd for ObjectKey {
    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
        Some(self.cmp(other))
    }
}

impl PartialEq for ObjectKey {
    fn eq(&self, other: &Self) -> bool {
        self.blocks == other.blocks && self.ino == other.ino
    }
}

#[cfg(test)]
mod tests {
    use crossbeam_channel::bounded;

    use super::*;

    #[test]
    fn smoke() {
        crate::tests::init_env_logging();

        let mut inventory_map = InventoryMap::new();
        inventory_map.insert(ObjectPath::new("Cargo.toml"));
        assert!(inventory_map.contains(ObjectPath::new("Cargo.toml")));
        assert!(!inventory_map.contains(ObjectPath::new("src/lib.rs")));
    }

    #[test]
    fn insert_remove() {
        crate::tests::init_env_logging();

        let mut inventory_map = InventoryMap::new();

        inventory_map.insert(ObjectPath::new("Cargo.toml"));
        inventory_map.insert(ObjectPath::new("Cargo.toml"));
        inventory_map.insert(ObjectPath::new("src/lib.rs"));
        assert!(inventory_map.contains(ObjectPath::new("Cargo.toml")));
        assert!(inventory_map.contains(ObjectPath::new("src/lib.rs")));

        inventory_map.remove(ObjectPath::new("Cargo.toml"));
        assert!(!inventory_map.contains(ObjectPath::new("Cargo.toml")));
        inventory_map.remove(ObjectPath::new("src/lib.rs"));
        assert!(!inventory_map.contains(ObjectPath::new("src/lib.rs")));
    }
}
