use std::sync::Arc;
use std::io;
use std::collections::{BTreeMap, HashMap, HashSet};
use std::thread;

use parking_lot::{Mutex, RwLock};
use dirinventory::{openat, InventoryEntryMessage, ObjectPath};
use crossbeam_channel::Receiver;
use openat::{metadata_types, Metadata};
#[allow(unused_imports)]
use log::{debug, error, info, trace, warn};
use itertools::Itertools;

use crate::objectlist::ObjectList;

type ObjectMap = BTreeMap<ObjectKey, ObjectList>;
type PerDeviceMaps = HashMap<metadata_types::dev_t, Arc<RwLock<ObjectMap>>>;

/// Stores all paths generated by the inventory gather pass.  The Inventory stores paths in
/// sub maps per device id, each sorted by size and inode.
#[derive(Debug)]
pub struct Inventory {
    shards:     Vec<Mutex<PerDeviceMaps>>,
    index_mask: usize,
}

impl Inventory {
    /// Create a new Inventory with pow(2, shards_log2) shards (power of two).
    pub fn new(
        shards_log2: u8,
        num_threads: usize,
        receiver: Receiver<InventoryEntryMessage>,
    ) -> Arc<Inventory> {
        let n = 1usize << shards_log2;

        let inventory = Arc::new(Inventory {
            shards:     (0..n).map(|_| Mutex::new(HashMap::new())).collect(),
            index_mask: n - 1,
        });

        let receiver = Arc::new(receiver);
        (0..num_threads).for_each(|n| {
            let receiver = receiver.clone();
            let inventory = inventory.clone();
            thread::Builder::new()
                .name(format!("inventory/{}", n))
                .spawn(move || {
                    debug!("thread started");
                    loop {
                        use crate::inventory::InventoryEntryMessage::*;
                        match receiver.recv().unwrap() {
                            Metadata(path, metadata) => {
                                inventory.insert_with_metadata(path, &metadata);
                            }
                            Entry(_, _, _) => { /* ignored, unused */ }
                            EndOfDirectory(_) => { /*ignored*/ }
                            Err(DynError) => { /*TODO: pass error up */ }
                            Done => {
                                // TODO: send message block feed, start fastrmrf
                                inventory.fastrmrf_files();
                            }
                        }
                    }
                });
        });

        inventory
    }

    fn fastrmrf_files(&self) {
        for device in self.devices() {
            // find/arc-clone all maps for each device
            let mut per_device = Vec::new();
            for shard in &self.shards {
                if let Some(device_map) = shard.lock().get(&device) {
                    let device_map = device_map.clone();
                    per_device.push(device_map);
                }
            }

            // get locks on all objectmaps for device
            let mut maplocks: Vec<_> = per_device.iter().map(|lock| lock.write()).collect();

            // create a merge sorted iterator in descending order
            let merged_iterator = maplocks
                .iter_mut()
                .map(|l| l.iter_mut().rev())
                .kmerge_by(|(a, _), (b, _)| a.blocks > b.blocks);

            todo!();
            // for item in merged_iterator {
            //     println!("ITEM: {:?}", item.0.blocks);
            // }
        }
    }

    /// Returns a HashSet of all known device identifiers.
    pub fn devices(&self) -> HashSet<metadata_types::dev_t> {
        let mut devices = HashSet::new();

        for shard in &self.shards {
            for device in shard.lock().keys() {
                devices.insert(*device);
            }
        }

        devices
    }

    // Insert the given path, using the supplied metadata to determine where the path will be stored.
    pub fn insert_with_metadata(
        &self,
        path: Arc<ObjectPath>,
        metadata: &Metadata,
    ) -> io::Result<()> {
        let key = ObjectKey::try_from(metadata).ok_or(io::Error::from(io::ErrorKind::NotFound))?;

        // lock shard
        let mut shard = self.shards[key.bucket_hash() & self.index_mask].lock();

        // lock the the btree map
        let map = shard
            .entry(
                metadata
                    .dev()
                    .ok_or(io::Error::from(io::ErrorKind::NotFound))?,
            )
            .or_insert(Arc::new(RwLock::new(BTreeMap::new())))
            .clone();
        // hand-over-hand locking, don't need the shard anymore
        drop(shard);

        // and get/create the objectlist, insert path
        map.write()
            .entry(key)
            .or_insert(ObjectList::new())
            .insert(path);

        Ok(())
    }

    /// Remove the given path under the supplied metadata from the inventory.
    pub fn remove_with_metadata(
        &self,
        path: Arc<ObjectPath>,
        metadata: &Metadata,
    ) -> io::Result<()> {
        let key = ObjectKey::try_from(metadata).ok_or(io::Error::from(io::ErrorKind::NotFound))?;

        let shard = self.shards[key.bucket_hash() & self.index_mask].lock();

        let map = shard
            .get(
                &metadata
                    .dev()
                    .ok_or(io::Error::from(io::ErrorKind::NotFound))?,
            )
            .ok_or(io::Error::from(io::ErrorKind::NotFound))?
            .clone();
        drop(shard);

        map.write()
            .get_mut(&key)
            .ok_or(io::Error::from(io::ErrorKind::NotFound))?
            .remove(path);

        Ok(())
    }

    /// Checks if the given path/metadata exists in the inventory.
    pub fn contains_with_metadata(&self, path: Arc<ObjectPath>, metadata: &Metadata) -> bool {
        ObjectKey::try_from(metadata)
            .and_then(|key| {
                let hash = key.bucket_hash();
                Some((
                    key,
                    self.shards[hash & self.index_mask].lock(),
                    metadata.dev()?,
                ))
            })
            .and_then(|(key, shard, dev)| Some((key, shard.get(&dev)?.clone())))
            .and_then(|(key, map)| Some(map.read().get(&key)?.contains(path)))
            .unwrap_or(false)
    }

    /// Insert existing path (on filesystem) into the inventory. Retrives the metadata from the
    /// path.  Will result in an error when the metadata of the given path can't be retrieved.
    pub fn insert(&self, path: Arc<ObjectPath>) -> io::Result<()> {
        let metadata = path.metadata()?;
        self.insert_with_metadata(path, &metadata)
    }

    /// Remove existing path (on filesystem) from the inventory. Retrives the metadata from the
    /// path.  Will result in an error when the metadata of the given path can't be retrieved.
    pub fn remove(&self, path: Arc<ObjectPath>) -> io::Result<()> {
        let metadata = path.metadata()?;
        self.remove_with_metadata(path, &metadata)
    }

    /// Check if an existing path (on filesystem) exists in the inventory. Retrives the
    /// metadata from the path.  Will return false when the metadata of the given path can't be
    /// retrieved.
    pub fn contains(&self, path: Arc<ObjectPath>) -> bool {
        path.metadata()
            .and_then(|metadata| Ok(self.contains_with_metadata(path, &metadata)))
            .unwrap_or(false)
    }
}

/// Objects are looked up by size and inode number combined here.
#[derive(Debug, Eq)]
struct ObjectKey {
    blocks: metadata_types::blkcnt_t,
    ino:    metadata_types::ino_t,
}

impl ObjectKey {
    /// Create a ObjectKey from the given metadata. May fail and return None when the metadata
    /// entries can't be acquired.
    fn try_from(metadata: &Metadata) -> Option<ObjectKey> {
        Some(ObjectKey {
            blocks: metadata.blocks()?,
            ino:    metadata.ino()?,
        })
    }

    /// Extremely simple hashing to determine the shard where the object is stored.
    fn bucket_hash(&self) -> usize {
        let mut h = self.blocks as usize ^ self.ino as usize;
        h = h ^ (h >> (usize::BITS / 2));
        h ^ (h >> (usize::BITS / 2))
    }
}

use std::cmp::Ordering;
impl Ord for ObjectKey {
    fn cmp(&self, other: &Self) -> Ordering {
        let r = self.blocks.cmp(&other.blocks);
        if r == Ordering::Equal {
            self.ino.cmp(&other.ino)
        } else {
            r
        }
    }
}

impl PartialOrd for ObjectKey {
    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
        Some(self.cmp(other))
    }
}

impl PartialEq for ObjectKey {
    fn eq(&self, other: &Self) -> bool {
        self.blocks == other.blocks && self.ino == other.ino
    }
}

#[cfg(test)]
mod tests {
    use crossbeam_channel::bounded;

    use super::*;

    #[test]
    fn smoke() {
        crate::tests::init_env_logging();

        let (_sender, receiver) = bounded(0);
        let inventory = Inventory::new(1, 0, receiver);

        inventory.insert(ObjectPath::new("Cargo.toml"));
        assert!(inventory.contains(ObjectPath::new("Cargo.toml")));
        assert!(!inventory.contains(ObjectPath::new("src/lib.rs")));
    }

    #[test]
    fn insert_remove() {
        crate::tests::init_env_logging();

        let (_sender, receiver) = bounded(0);
        let inventory = Inventory::new(4, 0, receiver);

        inventory.insert(ObjectPath::new("Cargo.toml"));
        inventory.insert(ObjectPath::new("Cargo.toml"));
        inventory.insert(ObjectPath::new("src/lib.rs"));
        assert!(inventory.contains(ObjectPath::new("Cargo.toml")));
        assert!(inventory.contains(ObjectPath::new("src/lib.rs")));

        inventory.remove(ObjectPath::new("Cargo.toml"));
        assert!(!inventory.contains(ObjectPath::new("Cargo.toml")));
        inventory.remove(ObjectPath::new("src/lib.rs"));
        assert!(!inventory.contains(ObjectPath::new("src/lib.rs")));
    }
}
